{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Manual Testing: A Complete Guide","text":"<p>This course provides a comprehensive introduction to manual software testing and its applications in real-world projects. You\u2019ll start with testing fundamentals\u2014covering SDLC, STLC, types of testing, test design techniques, test planning, and defect management\u2014before diving into advanced topics like exploratory testing, mobile/web application testing, performance basics, security basics, and best practices for testers.</p> <p>Whether you're a beginner or an aspiring QA professional, this guide will equip you with the skills to test software effectively and become a proficient manual tester. </p>"},{"location":"#course-topics","title":"\ud83d\udcd6 Course Topics","text":"<p>For a detailed breakdown of the course topics, check out the Course Overview.</p>"},{"location":"#chapter-1-introduction-to-software-testing","title":"\ud83d\udcda Chapter 1 - Introduction to Software Testing","text":"Main Topic Sub Topic Introduction to Software Testing What is Software Testing? Why Testing is Important Difference Between Manual and Automated Testing Software Development Life Cycle (SDLC) Software Testing Life Cycle (STLC)"},{"location":"Difference_Between_Manual_and_Automated_Testing/","title":"Difference Between Manual and Automated Testing","text":"Difference Between Manual and Automated Testing Technical Definition <ul> <li>Manual Testing: The process of executing test cases manually without automation tools. It relies on human effort, intuition, and observation.  </li> <li>Automated Testing: The process of executing test cases automatically using scripts and tools. It improves speed, accuracy, and repeatability.  </li> </ul> Storytelling <p>Imagine you\u2019re proofreading a book. - In manual proofreading, you read page by page, carefully spotting spelling or grammar mistakes. - In automated proofreading, you use a tool like Grammarly\u2014it checks quickly but may miss the creative flow or context.  </p> <p>Similarly, manual testers focus on usability and unexpected behaviors, while automated testing covers repetitive checks efficiently.  </p> Real-World Situation <ul> <li>Manual: Checking a new app\u2019s UI for user-friendliness.  </li> <li>Automated: Running regression tests on an e-commerce app to ensure discounts still apply correctly after a code update.  </li> </ul>"},{"location":"Software_Development_LifeCycle/","title":"Software Development Life Cycle (SDLC)","text":"Software Development Life Cycle (SDLC)  Technical Definition <p>SDLC is a structured process that defines the steps involved in developing high-quality software. It includes phases like: - Requirement Analysis - Design - Implementation - Testing - Deployment - Maintenance  </p> Storytelling <p>Think of SDLC as building a house: - You first gather requirements (what kind of house). - Create designs (blueprints). - Build the foundation and structure (coding). - Inspect the house (testing). - Hand over the keys (deployment). - Maintain it (repairs, updates).  </p> <p>Without SDLC, building software would be like randomly throwing bricks together and hoping a house forms!  </p> <p>When creating a banking app: - Requirements \u2192 features like money transfer, balance check. - Design \u2192 UI/UX screens and database design. - Implementation \u2192 coding. - Testing \u2192 verifying money is transferred correctly. - Deployment \u2192 launching app to customers. - Maintenance \u2192 updating features, fixing bugs.  </p>"},{"location":"Software_Testing_LifeCycle/","title":"Software Testing Life Cycle (STLC)","text":"Software Testing Life Cycle Technical Definition <p>STLC defines the phases involved in the testing process, ensuring that quality is maintained. Phases include: - Requirement Analysis - Test Planning - Test Case Development - Environment Setup - Test Execution - Test Closure  </p> Storytelling <p>Think of STLC as preparing for an exam: - Requirement Analysis \u2192 checking syllabus. - Planning \u2192 creating a study schedule. - Test Case Development \u2192 writing down possible questions. - Environment Setup \u2192 arranging books, internet, study space. - Execution \u2192 giving the exam. - Closure \u2192 reviewing performance and results.  </p> <p>Just like exam prep ensures success, STLC ensures software is tested thoroughly.  </p> Real-World Situation <p>Testing an online food delivery app: - Analyze requirements \u2192 login, search food, place order. - Plan \u2192 what to test, who will test, timelines. - Develop test cases \u2192 \u201cWhat if user enters wrong address?\u201d - Setup \u2192 test environment with mock payments. - Execute \u2192 run tests manually/automated. - Closure \u2192 prepare final test report.  </p>"},{"location":"course_overview/","title":"Course Topics","text":"Manual Testing Course Curriculum Module 1: Course Overview &amp; Fundamentals Course Introduction and Objectives <ul> <li>Manual Testing Fundamentals</li> <li>Introduction to Software Testing</li> <li>What is Software Testing?</li> <li>Why Testing is Important</li> <li>Difference Between Manual and Automated Testing</li> <li>Software Development Life Cycle (SDLC)</li> <li>Testing Life Cycle (STLC)</li> </ul> Module 2: Types of Testing <ul> <li>Functional Testing vs Non-Functional Testing</li> <li>Smoke, Sanity, and Regression Testing</li> <li>Integration Testing</li> <li>System Testing</li> <li>User Acceptance Testing (UAT)</li> </ul> Module 3: Test Design Techniques <ul> <li>Boundary Value Analysis (BVA)</li> <li>Equivalence Partitioning</li> <li>Decision Table Testing</li> <li>State Transition Testing</li> <li>Exploratory Testing</li> <li>Techniques and Heuristics</li> <li>Use Case Testing</li> <li>Orthogonal Array Testing</li> <li>Risk-Based Testing</li> </ul> Module 4: Test Planning &amp; Documentation <ul> <li>Test Plan Creation</li> <li>Test Strategy vs Test Plan</li> <li>Writing Test Cases</li> <li>Test Case Templates</li> <li>Hands-on Practice</li> <li>Test Data Preparation</li> <li>Traceability Matrix</li> <li>Test Metrics &amp; Reporting</li> </ul> Module 5: Defect Management <ul> <li>What is a Defect?</li> <li>Defect Life Cycle</li> <li>Severity vs Priority</li> <li>Defect Reporting Tools (JIRA, Bugzilla)</li> <li>Hands-on Practice: Logging Defects</li> </ul> Module 6: Testing Environments &amp; Tools <ul> <li>Understanding Testing Environments</li> <li>Version Control Basics (Git)</li> <li>Test Management Tools Overview</li> <li>Exploratory Testing Tools</li> <li>Web &amp; Mobile Testing Basics</li> <li>Cross-Browser Testing</li> <li>Responsive Testing</li> </ul> Module 7: Advanced Manual Testing Topics <ul> <li>Performance Testing Basics (Manual Perspective)</li> <li>Security Testing Basics (Manual Perspective)</li> <li>Mobile Application Testing</li> <li>Web Application Testing</li> <li>Exploratory Testing in Practice</li> </ul> Module 8: Best Practices &amp; Career Tips <ul> <li>Test Documentation Best Practices</li> <li>How to Become a Successful Tester</li> <li>Preparing for Manual Testing Interviews</li> </ul> Optional Hands-on Projects <ul> <li>Creating Test Cases for a Sample Application</li> <li>Logging Defects in JIRA/Bugzilla</li> <li>Performing Exploratory Testing on a Demo Website</li> </ul>"},{"location":"manual_testing_fundamentals/","title":"Introduction to Software Testing & Manual Testing Fundamentals","text":"Introduction to Software Testing &amp; Manual Testing Fundamentals Introduction to Software Testing <p>Think of software testing like baking a cake. You have a recipe (requirements), ingredients (the code), and an oven (the environment). Following the recipe is important\u2014but you also taste, smell, and check the texture to ensure everything turns out right. Testing is that taste test: it ensures your cake (software) is ready to delight the guests (users).</p> <p>The purpose of software testing is simple: deliver software that works reliably and satisfies users. But it\u2019s more than just finding bugs\u2014it builds confidence. Developers, managers, and customers trust the software because they know it has been thoroughly tested.</p> <p>For example, imagine a shopping app. When a user adds items to the cart and checks out, they expect the total to be correct and payment to go through smoothly. Without testing, a single mistake could cost users money and damage the company\u2019s reputation.</p> Manual Testing Fundamentals <p></p> <p>Imagine you\u2019re an explorer stepping into a brand-new city for the first time. The streets twist and turn, alleys hide surprises, and every corner could hold something unexpected. Your mission? To map the city carefully, note every detail, and report anything unusual so future travelers won\u2019t get lost.</p> <p>This is exactly what a manual tester does\u2014but instead of a city, the terrain is software. You navigate the application like a user, interacting with every feature, button, and link. You try logging in with correct credentials\u2014does it work? You enter a wrong password\u2014does it show the proper error? Click \u201cForgot Password\u201d\u2014does it trigger a reset email? Every action and observation helps ensure the software behaves as expected.</p> <p>Unlike automated testing, manual testing doesn\u2019t rely on scripts or tools. It relies on human intuition, creativity, and observation\u2014qualities that catch subtle issues machines might miss. Even in a world dominated by automation, manual testing remains irreplaceable.</p>"},{"location":"what_is_software_testing/","title":"What is Software Testing","text":"What is Software Testing? <p>Definition: Software testing is the process of evaluating a software application or system to determine whether it meets specified requirements and works as intended. It involves the systematic execution of test cases to identify defects, ensure quality, and validate that the software performs correctly in expected scenarios.</p> <p>Key Points:</p> <ul> <li>Purpose: Detect defects, ensure correctness, reliability, performance, and user satisfaction.</li> <li>Scope: Can include functional testing, non-functional testing, verification, and validation.</li> <li>Approach: Involves manual testing, automated testing, or a combination of both.</li> <li>Outcome: Provides confidence in the software\u2019s quality and suitability for release.</li> </ul> <p>In short:</p> <p>Software testing ensures that the software is both correct and fit for its intended use.</p> Verification and Validation in Software Testing"},{"location":"what_is_software_testing/#verification","title":"Verification","text":"<p> checking each stage of construction</p> <p>Definition: Verification is the process of evaluating work-products of a development phase to ensure that they meet the specified requirements and design specifications. It answers the question:</p> <p>\u201cAre we building the product correctly?\u201d</p> <p>Key Points:</p> <ul> <li>Focuses on process and documentation.</li> <li>Ensures that the software is being developed according to the specified requirements.</li> <li>Typically performed through reviews, inspections, walkthroughs, and static analysis.</li> </ul> <p>Example: Checking that a system design document correctly implements all specified requirements before coding begins.</p>"},{"location":"what_is_software_testing/#validation","title":"Validation","text":"<p> checking once the construction is complete</p> <p>Definition: Validation is the process of evaluating the final software product to check whether it meets the business needs and fulfills its intended purpose. It answers the question:</p> <p>\u201cAre we building the right product?\u201d</p> <p>Key Points:</p> <ul> <li>Focuses on the actual product behavior.</li> <li>Ensures that the software works as intended in real-world scenarios.</li> <li>Typically performed through dynamic testing, such as functional, system, and acceptance testing.</li> </ul> <p>Example: Testing an e-commerce application to verify that customers can successfully add items to the cart, checkout, and receive order confirmation as expected.</p> <p>In short:</p> <ul> <li>Verification = building the product right</li> <li>Validation = building the right product</li> </ul> <p>Software testing is like inspecting a house under construction.</p> <ul> <li>Verification: Are we building the house correctly according to the blueprint?</li> <li>Validation: Is this the right house for the people who will live in it?</li> </ul> <p>Testing early is like spotting a crack in the foundation before moving in. Fixing it is much cheaper and easier than repairing it later. Consider an online banking system: if a transaction fails due to a bug after launch, the financial impact could be enormous. Catching it early avoids disaster.</p>"},{"location":"why_testing_is_important/","title":"Why testing is important","text":"Why Testing is Important <p>Imagine launching a new rollercoaster at a theme park. You want it thrilling\u2014but more importantly, it must be safe. Testing ensures it moves correctly, the brakes work, seats are secure, and riders are safe.</p> <p>Software is no different. Testing ensures:</p> <ul> <li>Quality: Users trust the software works correctly.</li> <li>User Satisfaction: Bugs frustrate users just like a broken ride frustrates visitors.</li> <li>Cost Efficiency: Fixing issues early is far cheaper than post-release corrections.</li> <li>Security &amp; Performance: Software must be safe, fast, and reliable.</li> <li>Critical Defect Prevention: Some bugs can cause financial, safety, or reputational damage.</li> </ul> <p>Think about software in banking, healthcare, automotive, and government systems. Even a tiny defect can have catastrophic consequences.</p> Real-Life Examples <ul> <li>Ariane 5 Rocket (1996) \u2013 A bug in the inertial reference system caused the rocket to explode 40 seconds after launch. Loss: \\$370 million. Lesson: Critical systems demand thorough testing.</li> <li>Knight Capital Group (2012) \u2013 Poor testing in a trading platform triggered thousands of unintended trades in 45 minutes, causing a \\$440 million loss. Lesson: Even minor changes need exhaustive testing.</li> <li>Therac-25 Radiation Machine (1985\u20131987) \u2013 Software errors caused patients to receive massive overdoses of radiation, resulting in at least 6 deaths. Lesson: Testing is vital in safety-critical systems like healthcare.</li> <li>Toyota Recall (2009\u20132011) \u2013 Millions of cars recalled due to unintended acceleration caused by software glitches. Lesson: Automotive software must be rigorously tested\u2014lives depend on it.</li> <li>Healthcare.gov Launch (2013) \u2013 Website crashed due to inadequate load, integration, and user acceptance testing, impacting millions of users. Lesson: Large-scale web applications need thorough testing to handle stress and volume.</li> </ul> <p>Takeaway: Testing is not just a phase\u2014it\u2019s a safeguard. It ensures software works correctly, safely, and reliably, protecting both users and organizations from catastrophic failures. Just like a rollercoaster relies on safety checks, software relies on testing to deliver a smooth, dependable experience.</p>"}]}